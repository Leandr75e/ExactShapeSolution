// Translations Object
const translations = {
    fr: {
        meta: { title: "ExactShape Solutions - Numérisation 3D & Rétro-ingénierie" },
        nav: {
            activity: "Activité",
            commitment: "Engagement",
            projects: "Projets",
            method: "Méthode",
            contact: "Contact"
        },
        hero: {
            title: "Numérisation 3D & <span class=\"accent\">Rétro-ingénierie</span>",
            subtitle: "Transformation de pièces physiques en modèles 3D exploitables. Précision, méthode et résultats fiables pour vos projets techniques.",
            cta: "Discutons de votre projet"
        },
        presentation: {
            title: "Ce que je fais",
            subtitle: "ExactShape Solutions accompagne vos besoins en numérisation 3D et rétro-ingénierie",
            card1: {
                title: "Scan 3D",
                text: "Numérisation précise de pièces physiques pour capturer leur géométrie complexe et créer une base de travail fiable."
            },
            card2: {
                title: "Rétro-ingénierie",
                text: "Transformation de scans 3D en modèles CAO exploitables, adaptés à vos besoins de fabrication ou de modification."
            },
            card3: {
                title: "Modélisation CAO",
                text: "Création de modèles 3D précis à partir de pièces existantes, avec une attention particulière portée à l'exploitabilité du résultat."
            }
        },
        engagement: {
            title: "Mon engagement",
            subtitle: "Une méthode rigoureuse pour des résultats fiables et exploitables",
            step1: {
                title: "Définition du besoin",
                text: "Chaque projet commence par une compréhension claire de vos objectifs et contraintes techniques. Cette étape est essentielle pour garantir un résultat aligné avec vos attentes."
            },
            step2: {
                title: "Cadrage du résultat",
                text: "Nous établissons ensemble les critères de qualité et les spécifications techniques du livrable, pour une base de travail solide et partagée."
            },
            step3: {
                title: "Ajustements intégrés",
                text: "La démarche inclut des validations intermédiaires et des ajustements si nécessaire, pour garantir que le résultat final correspond exactement à votre besoin."
            },
            step4: {
                title: "Résultat exploitable",
                text: "Le modèle livré est pensé pour être directement utilisable dans votre chaîne de production, modification ou fabrication."
            }
        },
        projects: {
            title: "Exemples de projets",
            subtitle: "Situations types traitées et valeur apportée",
            common: {
                need: "Besoin",
                work: "Travail réalisé"
            },
            card1: {
                title: "Pièce cassée ou introuvable",
                need: "Remplacer une pièce qui n'est plus disponible ou dont les plans n'existent pas.",
                work: "Scan 3D de la pièce existante (ou des fragments), rétro-ingénierie et modélisation CAO pour permettre la refabrication."
            },
            card2: {
                title: "Adaptation d'une pièce",
                need: "Modifier une pièce existante pour l'adapter à un nouveau contexte ou à de nouvelles contraintes.",
                work: "Numérisation de la pièce d'origine, modélisation CAO et intégration des modifications requises pour le nouveau cahier des charges."
            },
            card3: {
                title: "Alignement de scan existant",
                need: "Exploiter un scan 3D déjà réalisé mais non référencé ou mal orienté.",
                work: "Mise en référence du scan dans un système de coordonnées cohérent, nettoyage et préparation pour utilisation en CAO."
            },
            card4: {
                title: "Pièce non mesurable",
                need: "Capturer la géométrie d'une pièce complexe, difficile d'accès ou impossible à mesurer avec des outils classiques.",
                work: "Scan 3D haute précision et transformation en modèle CAO exploitable pour analyse, modification ou fabrication."
            }
        },
        method: {
            title: "Ma méthode de travail",
            subtitle: "Un processus clair et transparent, de l'expression du besoin à la livraison",
            step1: {
                title: "1. Compréhension du besoin",
                text: "Échange initial pour clarifier vos objectifs, contraintes techniques et contexte d'utilisation du modèle final."
            },
            step2: {
                title: "2. Définition de l'approche",
                text: "Proposition d'une méthode adaptée (scan, rétro-ingénierie, modélisation) et validation du cadre de travail."
            },
            step3: {
                title: "3. Travail et ajustements",
                text: "Réalisation du projet avec des points de validation intermédiaires pour garantir l'alignement avec vos attentes."
            },
            step4: {
                title: "4. Livraison du résultat",
                text: "Remise du modèle 3D final dans le format souhaité, prêt à être intégré dans votre processus de travail."
            }
        },
        contact: {
            title: "Parlons de votre projet",
            text: "Vous avez un besoin en numérisation 3D ou rétro-ingénierie ? Décrivez-moi votre projet, nous échangerons sans engagement pour définir ensemble la meilleure approche.",
            cta: "Me contacter"
        },
        footer: {
            text: "&copy; 2026 ExactShape Solutions - Numérisation 3D & Rétro-ingénierie"
        }
    },
    en: {
        meta: { title: "ExactShape Solutions - 3D Scanning & Reverse Engineering" },
        nav: {
            activity: "Services",
            commitment: "Commitment",
            projects: "Projects",
            method: "Method",
            contact: "Contact"
        },
        hero: {
            title: "3D Scanning & <span class=\"accent\">Reverse Engineering</span>",
            subtitle: "Transforming physical parts into usable 3D models. Precision, method, and reliable results for your technical projects.",
            cta: "Let's discuss your project"
        },
        presentation: {
            title: "What I do",
            subtitle: "ExactShape Solutions supports your 3D scanning and reverse engineering needs",
            card1: {
                title: "3D Scanning",
                text: "Precise digitization of physical parts to capture complex geometry and create a reliable working base."
            },
            card2: {
                title: "Reverse Engineering",
                text: "Transforming 3D scans into usable CAD models, tailored to your manufacturing or modification needs."
            },
            card3: {
                title: "CAD Modeling",
                text: "Creation of precise 3D models from existing parts, with particular attention to result usability."
            }
        },
        engagement: {
            title: "My Commitment",
            subtitle: "A rigorous method for reliable and usable results",
            step1: {
                title: "Defining Needs",
                text: "Every project starts with a clear understanding of your objectives and technical constraints. This step is essential to ensure a result aligned with your expectations."
            },
            step2: {
                title: "Result Framework",
                text: "We establish quality criteria and technical specifications together, ensuring a solid and shared foundation."
            },
            step3: {
                title: "Integrated Adjustments",
                text: "The process includes intermediate validations and adjustments if necessary, ensuring the final result matches your needs exactly."
            },
            step4: {
                title: "Usable Result",
                text: "The delivered model is designed to be directly usable in your production, modification, or manufacturing chain."
            }
        },
        projects: {
            title: "Project Examples",
            subtitle: "Typical situations handled and value provided",
            common: {
                need: "Need",
                work: "Work Performed"
            },
            card1: {
                title: "Broken or Obsolete Part",
                need: "Replace a part that is no longer available or for which no blueprints exist.",
                work: "3D scan of the existing part (or fragments), reverse engineering, and CAD modeling to enable remanufacturing."
            },
            card2: {
                title: "Part Adaptation",
                need: "Modify an existing part to adapt it to a new context or new constraints.",
                work: "Digitization of the original part, CAD modeling, and integration of required modifications for the new specifications."
            },
            card3: {
                title: "Existing Scan Alignment",
                need: "Utilize a 3D scan already performed but not referenced or poorly oriented.",
                work: "Referencing the scan in a coherent coordinate system, cleaning, and preparation for CAD use."
            },
            card4: {
                title: "Non-Measurable Part",
                need: "Capture the geometry of a complex part, difficult to access or impossible to measure with standard tools.",
                work: "High-precision 3D scan and transformation into a usable CAD model for analysis, modification, or manufacturing."
            }
        },
        method: {
            title: "My Workflow",
            subtitle: "A clear and transparent process, from need expression to delivery",
            step1: {
                title: "1. Understanding Needs",
                text: "Initial exchange to clarify your objectives, technical constraints, and usage context of the final model."
            },
            step2: {
                title: "2. Approach Definition",
                text: "Proposal of a suitable method (scan, reverse engineering, modeling) and validation of the framework."
            },
            step3: {
                title: "3. Work & Adjustments",
                text: "Project execution with intermediate validation points to ensure alignment with your expectations."
            },
            step4: {
                title: "4. Result Delivery",
                text: "Delivery of the final 3D model in the desired format, ready to be integrated into your workflow."
            }
        },
        contact: {
            title: "Let's talk about your project",
            text: "Do you have a need for 3D scanning or reverse engineering? Describe your project to me, and we will discuss without obligation to define the best approach together.",
            cta: "Contact Me"
        },
        footer: {
            text: "&copy; 2026 ExactShape Solutions - 3D Scanning & Reverse Engineering"
        }
    }
};

// Header scroll effect
const header = document.getElementById('header');
window.addEventListener('scroll', () => {
    if (window.scrollY > 100) {
        header.classList.add('scrolled');
    } else {
        header.classList.remove('scrolled');
    }
});

// Parallax effect on hero
const hero = document.querySelector('.hero');
const heroContent = document.querySelector('.hero-content');
window.addEventListener('scroll', () => {
    const scrolled = window.scrollY;
    if (scrolled < window.innerHeight) {
        heroContent.style.transform = `translateY(${scrolled * 0.5}px)`;
        heroContent.style.opacity = 1 - (scrolled / window.innerHeight);
    }
});

// Fade-in animation on scroll
const fadeElements = document.querySelectorAll('.fade-in');

const fadeInObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('visible');
        }
    });
}, {
    threshold: 0.1,
    rootMargin: '0px 0px -100px 0px'
});

fadeElements.forEach(element => {
    fadeInObserver.observe(element);
});

// Language Switch Logic
const langSwitch = document.getElementById('langSwitch');
let currentLang = 'fr';

function updateContent(lang) {
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        const keys = key.split('.');
        let content = translations[lang];
        
        // Traverse the translation object using the key path (e.g., "nav.activity")
        for (const k of keys) {
            if (content[k]) {
                content = content[k];
            } else {
                content = null;
                break;
            }
        }

        if (content) {
            // Use innerHTML to preserve HTML tags (like spans in the Hero title)
            element.innerHTML = content;
        }
    });
}

langSwitch.addEventListener('click', () => {
    if (currentLang === 'fr') {
        currentLang = 'en';
        langSwitch.textContent = 'FR';
        document.documentElement.lang = 'en';
    } else {
        currentLang = 'fr';
        langSwitch.textContent = 'EN';
        document.documentElement.lang = 'fr';
    }
    updateContent(currentLang);
});

document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            const headerHeight = header.offsetHeight;
            const targetPosition = target.offsetTop - headerHeight;
            window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
            });
        }
    });
});

// Animation de la grille avec effet de scroll
const gridFloor = document.querySelector('.grid-floor');
let lastScrollTop = 0;

function animateGrid() {
    const scrollTop = window.scrollY;
    
    // Déplacement de la grille en fonction du scroll (effet parallaxe)
    const backgroundPos = (scrollTop * 0.01) % 80;
    
    if (gridFloor) {
        gridFloor.style.backgroundPositionY = `${backgroundPos}px`;
        
        // Rotation subtile de la grille pendant le scroll
        const rotation = 60 + (scrollTop * 0.01);
        gridFloor.style.transform = `translate(-50%, -50%) rotateX(${Math.min(rotation, 70)}deg)`;
    }
    
    requestAnimationFrame(animateGrid);
}

animateGrid();

function createParticles() {
    const container = document.getElementById('particles-container');
    if (!container) return;
    
    // Moins de particules sur mobile pour performances
    const particleCount = window.innerWidth > 768 ? 30 : 15;
    
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Ajouter des variantes de taille aléatoirement
        const rand = Math.random();
        if (rand < 0.3) particle.classList.add('small');
        else if (rand > 0.7) particle.classList.add('large');
        
        // Position horizontale aléatoire
        particle.style.left = Math.random() * 100 + '%';
        particle.style.bottom = '-10px';
        
        // Dérive horizontale aléatoire pendant la montée
        const drift = (Math.random() - 0.5) * 100;
        particle.style.setProperty('--drift', drift + 'px');
        
        // Délai de départ aléatoire
        particle.style.animationDelay = Math.random() * 8 + 's';
        
        container.appendChild(particle);
    }
}

// ====================================
// 2. WIREFRAME 3D (avec Three.js)
// ====================================
function createWireframe() {
    const container = document.getElementById('wireframe-container');
    if (!container || typeof THREE === 'undefined') return;
    
    // Création de la scène 3D
    const scene = new THREE.Scene();
    
    // Caméra
    const camera = new THREE.PerspectiveCamera(
        75, // Angle de vue
        container.offsetWidth / container.offsetHeight, // Ratio
        0.1, // Distance minimale
        1000 // Distance maximale
    );
    camera.position.z = 5;
    
    // Renderer (moteur de rendu)
    const renderer = new THREE.WebGLRenderer({ 
        alpha: true, // Fond transparent
        antialias: true // Lissage des bords
    });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setClearColor(0x000000, 0); // Fond transparent
    container.appendChild(renderer.domElement);
    
    // Géométrie : Icosaèdre (forme complexe à 20 faces)
    const geometry = new THREE.IcosahedronGeometry(2, 0);
    
    // Matériau wireframe (fil de fer)
    const material = new THREE.MeshBasicMaterial({
        color: 0xE95625, // Orange (votre couleur accent)
        wireframe: true,
        transparent: true,
        opacity: 0.6
    });
    
    const wireframe = new THREE.Mesh(geometry, material);
    scene.add(wireframe);
    
    // Ajouter des points lumineux aux sommets
    const pointsGeometry = new THREE.BufferGeometry();
    const positions = geometry.attributes.position.array;
    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    const pointsMaterial = new THREE.PointsMaterial({
        color: 0xE95625,
        size: 0.1,
        transparent: true,
        opacity: 0.8
    });
    
    const points = new THREE.Points(pointsGeometry, pointsMaterial);
    scene.add(points);
    
    // Animation de construction progressive
    let progress = 0;
    
    // Boucle d'animation
    function animate() {
        requestAnimationFrame(animate);
        
        // Rotation continue
        wireframe.rotation.x += 0.005;
        wireframe.rotation.y += 0.007;
        points.rotation.x += 0.005;
        points.rotation.y += 0.007;
        
        // Effet de pulsation (construction)
        progress += 0.01;
        const scale = 1 + Math.sin(progress) * 0.1;
        wireframe.scale.set(scale, scale, scale);
        points.scale.set(scale, scale, scale);
        
        renderer.render(scene, camera);
    }
    
    animate();
    
    // Adapter la taille si la fenêtre change
    window.addEventListener('resize', () => {
        if (window.innerWidth > 768) {
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        }
    });
}

// ====================================
// 3. MESH 3D INTERACTIF
// ====================================
function createInteractiveMesh() {
    const container = document.getElementById('mesh-container');
    if (!container || typeof THREE === 'undefined') return;
    
    // Scène 3D
    const scene = new THREE.Scene();
    
    // Caméra
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.z = 50;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ 
        alpha: true, 
        antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // Transparent
    container.appendChild(renderer.domElement);
    
    // Géométrie : Plan divisé en grille (pour ondulation)
    const geometry = new THREE.PlaneGeometry(100, 100, 50, 50);
    
    // Matériau
    const material = new THREE.MeshBasicMaterial({
        color: 0x242C5E, // Bleu foncé (votre couleur primaire)
        wireframe: true,
        transparent: true,
        opacity: 0.15 // Très subtil
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 3; // Incliné
    scene.add(mesh);
    
    // Variables pour suivre la souris
    let mouseX = 0;
    let mouseY = 0;
    
    // Écouter le mouvement de la souris
    document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    
    // Animation
    function animate() {
        requestAnimationFrame(animate);
        
        // Déformer la géométrie
        const positions = geometry.attributes.position.array;
        const time = Date.now() * 0.001;
        
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const y = positions[i + 1];
            
            // Ondulation de base (vagues)
            const wave1 = Math.sin(x * 0.1 + time) * 2;
            const wave2 = Math.cos(y * 0.1 + time) * 2;
            
            // Réaction à la souris
            const dx = x - (mouseX * 50);
            const dy = y - (mouseY * 50);
            const dist = Math.sqrt(dx * dx + dy * dy);
            const mouseEffect = Math.max(0, 5 - dist * 0.2) * 2;
            
            // Appliquer la déformation en Z (hauteur)
            positions[i + 2] = wave1 + wave2 + mouseEffect;
        }
        
        // Indiquer à Three.js que la géométrie a changé
        geometry.attributes.position.needsUpdate = true;
        
        // Rotation légère
        mesh.rotation.z += 0.001;
        
        renderer.render(scene, camera);
    }
    
    animate();
    
    // Responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// Attendre que la page soit chargée
window.addEventListener('load', function() {
    console.log('Page chargée');
    
    // Lancer les particules immédiatement
    createParticles();
    console.log('Particules créées');
    
    // Attendre que Three.js soit disponible
    if (typeof THREE !== 'undefined') {
        console.log('Three.js détecté');
        createWireframe();
        
        if (window.innerWidth > 768) {
            createInteractiveMesh();
        }
    } else {
        console.error('Three.js non chargé !');
    }
});